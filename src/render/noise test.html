<canvas></canvas>
<style>
  body,
  html {
    margin: 0;
    padding: 0;
    overflow: hidden;
    background: #000;
  }
  canvas {
    display: block;
  }
</style>
<script>
  const canvas = document.querySelector("canvas");
  const ctx = canvas.getContext("2d");
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  function worleyNoise3D(width, height, depth, gridSize, pointsPerCell = 1) {
    const gridCols = Math.ceil(width / gridSize);
    const gridRows = Math.ceil(height / gridSize);
    const gridDepts = Math.ceil(depth / gridSize);

    // Store feature points by grid cell for fast lookup
    const grid = Array.from({ length: gridCols }, () =>
      Array.from({ length: gridRows }, () =>
        Array.from({ length: gridDepts }, () => [])
      )
    );

    // Generate random feature points for each grid cell
    for (let gx = 0; gx < gridCols; gx++) {
      for (let gy = 0; gy < gridRows; gy++) {
        for (let gz = 0; gz < gridDepts; gz++) {
          for (let i = 0; i < pointsPerCell; i++) {
            grid[gx][gy][gz].push({
              x: gx * gridSize + Math.random() * gridSize,
              y: gy * gridSize + Math.random() * gridSize,
              z: gz * gridSize + Math.random() * gridSize
            });
          }
        }
      }
    }

    // Create 3D array
    const data = Array.from({ length: depth }, () =>
      Array.from({ length: height }, () => new Float32Array(width))
    );
    let maxDist = 0;

    // For each voxel, only consider feature points from neighboring cells
    for (let z = 0; z < depth; z++) {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          let minDist = Infinity;
          const gx = Math.floor(x / gridSize);
          const gy = Math.floor(y / gridSize);
          const gz = Math.floor(z / gridSize);

          // Check current cell and 26 neighbors (3x3x3 cube, with wrapping)
          for (let dx = -1; dx <= 1; dx++) {
            for (let dy = -1; dy <= 1; dy++) {
              for (let dz = -1; dz <= 1; dz++) {
                const ngx = (gx + dx + gridCols) % gridCols;
                const ngy = (gy + dy + gridRows) % gridRows;
                const ngz = (gz + dz + gridDepts) % gridDepts;
                for (const p of grid[ngx][ngy][ngz]) {
                  let dxp = Math.abs(p.x - x);
                  dxp = Math.min(dxp, width - dxp);
                  let dyp = Math.abs(p.y - y);
                  dyp = Math.min(dyp, height - dyp);
                  let dzp = Math.abs(p.z - z);
                  dzp = Math.min(dzp, depth - dzp);
                  const dist = dxp * dxp + dyp * dyp + dzp * dzp;
                  if (dist < minDist) minDist = dist;
                }
              }
            }
          }
          data[z][y][x] = minDist;
          if (minDist > maxDist) maxDist = minDist;
        }
      }
    }

    // Normalize distances
    for (let z = 0; z < depth; z++) {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          data[z][y][x] = Math.sqrt(data[z][y][x]) / Math.sqrt(maxDist);
        }
      }
    }
    return data;
  }
  function fractalWorleyNoise3D(
    width,
    height,
    depth,
    baseGridSize,
    octaves,
    persistence = 0.5
  ) {
    const data = Array.from({ length: depth }, () =>
      Array.from({ length: height }, () => new Float32Array(width).fill(0))
    );

    let amplitude = 1;
    let totalAmplitude = 0;

    for (let o = 0; o < octaves; o++) {
      const gridSize = baseGridSize / Math.pow(2, o);
      const octaveData = worleyNoise3D(width, height, depth, gridSize, 1);

      for (let z = 0; z < depth; z++) {
        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            // Invert Worley
            let v = 1.0 - octaveData[z][y][x];
            // Carve detail instead of add
            data[z][y][x] += v * amplitude;
          }
        }
      }

      totalAmplitude += amplitude;
      amplitude *= persistence;
    }

    // Normalize final data
    for (let z = 0; z < depth; z++) {
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          data[z][y][x] /= totalAmplitude;
        }
      }
    }

    return data;
  }
  const size = 64;
  const data = fractalWorleyNoise3D(size, size, size, 32, 4, 0.5);
  const noiseData = new Uint8ClampedArray(size * size * size * 4);
  let idx = 0;
  for (let z = 0; z < size; z++) {
    for (let y = 0; y < size; y++) {
      for (let x = 0; x < size; x++) {
        const v = Math.floor(data[z][y][x] * 255);
        noiseData[idx++] = v;
        noiseData[idx++] = v;
        noiseData[idx++] = v;
        noiseData[idx++] = 255;
      }
    }
  }

  let currentZ = 0;
  let renderRes = 32; // initial render resolution

  function drawSlice(z) {
    // Create a tileable pattern from the noiseData for the current Z slice
    const tileCanvas = document.createElement("canvas");
    tileCanvas.width = size;
    tileCanvas.height = size;
    const tileCtx = tileCanvas.getContext("2d");
    const imageData = tileCtx.createImageData(size, size);
    let idx = z * size * size * 4;
    for (let i = 0; i < size * size * 4; i++) {
      imageData.data[i] = noiseData[idx + i];
    }
    tileCtx.putImageData(imageData, 0, 0);

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.imageSmoothingEnabled = false;

    // Repeat the tile to fill the canvas at the desired renderRes
    for (let y = 0; y < canvas.height; y += renderRes) {
      for (let x = 0; x < canvas.width; x += renderRes) {
        ctx.drawImage(tileCanvas, 0, 0, size, size, x, y, renderRes, renderRes);
      }
    }
  }

  drawSlice(currentZ);

  window.addEventListener("keydown", (e) => {
    if (e.key === "ArrowUp") {
      currentZ = (currentZ + 1) % size;
      drawSlice(currentZ);
    } else if (e.key === "ArrowDown") {
      currentZ = (currentZ - 1 + size) % size;
      drawSlice(currentZ);
    }
  });

  // Scroll wheel to change render resolution (zoom in/out)
  window.addEventListener("wheel", (e) => {
    if (e.deltaY < 0) {
      // Zoom in (higher resolution)
      renderRes = Math.min(renderRes * 2, canvas.height, canvas.width);
    } else {
      // Zoom out (lower resolution)
      renderRes = Math.max(Math.floor(renderRes / 2), 4);
    }
    drawSlice(currentZ);
  });
</script>
